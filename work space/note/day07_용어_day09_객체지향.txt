클래스-
유사한 특징을 지닌 객체들의 속성을 묶어놓은집합체.




캡슐화 -	필드(멤버변수)	메소드(멤버함수)
필요한 속성과 행위를 하나로 묶고 그중 일부를
외부에서 사용하지 못하도록 은닉한다.(멤버변수를숨김)(클래스 내부에서만 가능)

상속 -자식클래스가 상속받고싶은 부모를 선택해서 상속받는다 이떄 상속받는 클래스를
자식클래스 하위클래스또는 서브클래스라고 부른다. 상속을 해주는 클래스를 부모클래스
상위클래스 또는 슈퍼클래스라고 부른다.

상속의 장점은 유지보수가 편해지며 중복된 코드수를 줄일수있다.재사용성을 높임
방법은 선언하는것인데 extends ~~~

(오버로드)다형성-
여러가지 형태를 가질수 있는 능력 한타입의 참조변수로 여러타입의 객체를 참조할수
있도록 함으로써 다형성을 프로그램적으로 구현하였다.

조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할수있도록 하였다는것이다. 

추상화 -강제성이 있음. 자식이 못받게하지않도록.
추상클래스는 미완성설계도와 같다. 완성되지못한채있는것 멤버의 개수와 관계된것이아니라
단지 미완성 메서드를 포함하고있다는 의미. 미완성된설계도로 제품을 만들수없듯이
추상클래스로 인스턴스는 생성할수없다. 추상클래스는 상속을 통해서 자손클래스에 의해서만 완성가능

추상메서드는 메서드는 선언부와 구현부로 구성돼있는데 선언부만 작성하고 구현부는 작성하지않은채로
남겨둔것이 추상메서드이다. 
그 이유는 메서드의 내용이 상속받는 클래스에따라 달라질수있기떄문에 조상클래스는 선언부만 작성하고 주석을 덧붙여
어떤 기능을 수행할 목적으로 작성됐는지 알려주고 실제내용은 상속받는 클래스에서
구현하도록 놔두는것.

접근제한자-
public,protected,default,private
한번에 네가지중 하나만 선택해서 사용가능하다.
멤버들은 객체 자신들만의 속성이자 특징이므로 외부에 공개되는것이 좋은것만은 아니다.
그런이유로 객체의 멤버들에게 제한을 걸수있다.이것을 접근제한자라고 부르고
퍼블릭 모든접근을 허용
프로텍티드같은 패키지(폴더)에있는 객체와 상속관계의 객체들만 허용
default 같은 패키지에있는 객체들만 허용
private 현재 객체내에서만 허용

- 클래스       : public, default

- 생성자       : public, protected, default, private

- 멤버변수    : public, protected, default, private

- 멤버메소드 : public, protected, default, private

- 지역변수    : 접근제한자 사용 불허

생성자 함수

  클래스에서 객체를 생성하는 방법을 제어하는 함수
생성자 함수를 사용하는 목적
타입이똑같아야함.
1-객체 생성시에 데이터(인스턴스 변수값)전달
2-객체가 생성될떄 동작을 하고 싶을떄.
기본 생성자 jvm이 제공하며 new클래스명();으로 객체를 생성
하나이상의 생성자 함수를 만들면 객체를 생성할떄에는 반드시 지정된
방법중에 하나의 방식으로 new 연산자를 사용한다.
객체를 위해서 만들떄에는 첫문자를 대문자로 만든다.
생성자: 객체를 생성하는 옵션.
생성자 함수를 정의하게되면 new로 만드는것이 안된다
생성자 함수는 리턴타입이 없고 이름과 똑같이 하면 된다.

멤버 변수및 멤버함수
만들어진 클래스를 사용하려면 클래스명 <클래스변수명>=new 클래스명으로 인스턴스를
만든후에 가능하고 그 이후에는 클래스변수명.변수,클래스변수명.함수()의 형식으로 사용
여기서 변수는 멤버 변수라고하고 함수()는 멤버함수라고한다.
자바에서는 함수를 통칭해서 메소드라고한다. 그리고 프로그램 실행은
public static void main()이 있는 클래스에서 해야한다.

오버로드(중복함수)-
오버로딩이름 같은이름의메소드를 중복해서 정의하느넋이다.
자바에서는 한 클래스 내 같은 이름의 메소드를 둘 이상 가질 수 없다.
하지만 매개변수의 개수나 타입을 다르게하면 하나의 이름으로 메소드를 작성할수있다.

이 방식으로 메소드에 사용되는 이름을 절약할수있다.
또한 메소드를 호출할떄 전달해야할 매개변수의타입이나 개수에 크게 상관하지않고
호출할수있게된다.다형성을 구현하는 방법중하나.

오버라이딩-
부모클래스에서 정의한 메서드를 자식 클래스에서 변경하는것.
어쩔수없이 부모클래스의 값을 변경해야할떄 필요하고 기본적인 조건은
메서드의 이름이 같아야한다. 리턴타입이 같아야한다.
static메서드의 오버라이딩을 허용하지않는다.

인스턴스-클래스의 정의를 통해 만들어진 객체를 의미
객체지향 프로그래밍적 관점에서 객체는 클래스의타입으로 선언됐을떄를
의미하는것이고 그 객체가 메모리에 할당돼 실제 컴퓨터에실행될떄를 인스턴스라고한다.
인스턴스는 추상화 개념 또는 클래스객체 컴퓨터프로세스등과같은
템플릿이 실제 구현된것이다.

객체- 객체는 선언을 의미한다. 현실세계에서 실제 사물을 객체라고 불러서
컴퓨터상에서도 실제 구현된 프로그램등만 객체가 아니라 개념등과같은것도
객체라고 부를수있다.그런데 객체는 인스턴스화를 통해 만든 실체이다.

오브젝트(객체)는 실체 인스턴스는 보통 관계에 집중한용어.

인터페이스-
인터페이스는 호환성이라고 이해를 많이하는편이다.
어떤 객체가 특정한 인터페이스를 사용한다면 그 객체는 반드시
인터페이스의 메소드들로 구현돼야한다.
그렇지않으면 컴파일조차 불가능하다.
하나의 클래스가 여러개의 인터페이스를 구현할수있다.
인터페이스도 상속이된다. 인터페이스의 멤버는 반드시 public이다.
그리고 상속의 extends와 달리implements 키워드를 사용해야한다.
자바는 1번밖에 상속을 못하지만 인터페이스를 이용하면 다중상속과 비슷하게된다.

추상클래스
하나이상의 추상 메소드를 포함하는 클래스이다. 추상메소드는 선언만 있고 본체는 없는 함수이며
인터페이스는 클래스와 별도로 일련의 연관된 메서드를 정의
추상클래스는 메서드를 선언하지만 모든 메서드를 선언하지않는 불완전하게 정의된 메서드
차이점은 인터페이스는 클래스가 아니지만 추상클래스는 클래스다.
추상클래스는 일반적으로 베이스 클래스로 상속해서 더 구체적인클래스를 만들떄 좋다.
인터페이스는 서로 관련이 없는 클래스에서 공통저긍로 사용하는 방식이 필요하지만
기능을 각각 국현할 경우 좋다.

static:객체들끼리 공유되는 값은 무조건 static으로 선언해야한다.
static=공유의 개념
static 3가짖 종류 변수,메소드,블록 
변수는 객체들끼리 공유하는 값이다. static{}형태로 구현되고 메모리에 올라가는순선서는
클래스에서 static한 어떤작업이 필요시 클래스파일->static블록->메인 메소드 순서로 메모리에 올라간다.
그렇기떄문에 메인메소드가실행되기이전에 STATIC블럭의 결과가 먼저 출력된다.



this
자바에서 this는 객체 자기자신을 나타냅니다 주로 3가지 형태로 사용되고있으며
1.클래스의 속성과 생성자 메소드의 매개변수의이름이 같은경우 -클래스 속성을 사용할떄 this.키워드르 붙여줌
일반적으로 생성자 또는 set/get메소드의 매개변수이름은 클래스의 속성이름과 동일하게 정의돼 사용된다.

2.클래스에 오버로딩된 다른 생성자 호출
생성자 최상단에 사용돼야 합니다.
하나의 클래스에 여러개의 생성자가 오버로딩 됐을떄 일부분을 제외하고는 서로 중복된 코드를
가지고있는경우가 많습니다.
이런순간에 내부에 정의된 다른 생성자를 호출하여 코드의 중복을 피하고 깔끔한 소스를 작성할수있다.
같은 클래스에 오버로딩된 다른생성자를 호출떄에도 this키워드가 사용된다.

3. 객체 자신의 참조값을 전달하고 싶을떄.
어떤 메소드에서는 동작을 완료하고 리턴값으로 어떤 메소드에서는 내부에서 호출하고자하는 메소드의
매개변수로 객체 자기자신의 참조값을 전달하고싶은경우가있다.이럴떄에는 getFruitInstance()메소드의
구현부분처럼 this키워드를 이용함으로써 구현이 가능하다.









day09--- 

built in 변수는 하나의 공간에 하나씩 넣어서 진행
배열은 변수가 많아졌을떄 담을수있는 공간을 넓히기위해서 만듦
문제는 데이터 타입이 한번 정의해주면 동일한 타입만 사용할수있다는것이다.
서로다른 데이터를 다룰수있게만들려고 구조체가 나옴 처음은 c++ 엄밀히말해 구조체까지는 c
ex park{
	String park
	k 80,e50,c70,avg,grade  <---여기서부터 "멤버변수"라고함.} 
struct park p;<--사용자 정의 자료형이고 p를 구조체변수라고말함 이제 동일데이터뿐만아니라 서로다른 변수를 처리할수있음.
 p.e=30; p.c=20;
p.park="park"<이렇게 생성자를만들어서 변경할수있게됨

그런데 문제는 접근해서 값을 변경하는게 누구나 가능해져서 이게 문제가 되는경우가 많음
내 전산점수를 마음대로 건들일수가있으니.

c++에서 private를 만들려고했는데 호환성의 문제로 바꾸지못함. 

이 상황을 타개할려고 class를 만들었음. 
ex)class park{
	string name;    <--여기까지가 멤버변수. c++은 여기서 접근지정자를 안붙이면 자체적으로 
	int kor,eng,com,total;	//  private가 붙음.,자바는 기본값인 default가됨.
	double avg;          //private에 접근하기위해서 public setname(String n){
}			//getname() return~ setkor(int n)~~~ 식으로 만들어서 값을 변경시켰음.
			//public setname등을 멤버함수라고함(공개)


자바의 경우는 변수 배열을 그대로 흡수했고 c++의 구조체개념을 버리고 바로 클래스개념을  흡수.
이떄 멤버변수를 data 멤버함수를 function의 역할을 함.

객체란? 실생활에있는 모든것이 객체
이것을 프로그래밍화를하면 예시로 의자를 들면 고유한 특징(속성)

속성<--멤버변수		기능<멤버함수
-재질			-앉을수있다
-모양			-굴러다닐수있다
-색상 			-올라설수도있고 여러 동작들을 멤버함수에 넣음.
			-재질함수
			-모양 함수
			-색상 함수
			
속성을 구체화하기위해서 멤버함수를만듦.'
이 두 멤버변수와 멤버함수를 하나로 묶어놓은 형태를 클래스라고한다.
클래스를 한마디로 요약하면 사용자 정의 자료형 설계도.

A클래스		B클래스
private int x,y;	private int a,b
privatex=3;		private char ch;
			ch='a'

	<--B에서 A로 직접접근안됨
현생활을 예시로들면 친구집을 내가 마음대로 갈수가있나? ㄴㄴ
친구랑같이가던가 열쇠를 받고 허락받고 가야함.
A도 마찬가지로 B로 직접접근불가능. 

이떄 열쇠를받고 들어가주는 역할이 객체
A a=new A();
a.  <--이방법으로 A클래스 값들을 건들수있음.
그렇다고해서 sysout(a.x=?);이방식 불가능

A의값 x=5라고한다면 
외부에서 이 x의값을 알수있는 메소드를 get메소드라고함.
함수기떄문에 블럭지정. int get(인자 xxx){ return x;}
이떄 return하는 자료의 타입이 있어야함. 

B클에서 A의 값을 바꾸고싶으면 set메소드가 필요함 마찬가지로 
void set(int xx){<==무슨형인지 적으면 xxx대신 (안에 적어야함)
x=xx
return}


void setch(char ss){
	ch=ss;
}<-B클래스 캐릭터값을 바꾸기위한 메소드
char getch(){
	return ch;
}  <-- B클래스의 ch값을 얻어오기위해서 적어줌.

그래서 sysout(a.get());등으로 만들어야함.
B b<-- 이떄 b가 클래스 변수이름 막만들어도됨. =new B();  <--B()는 생성자 함수 오브젝트를 만들어내는 함수
하지만 보통 오브젝트 ,인스턴스라고부름.

만약 함수변경을 못하게할려면 set함수를 안만들면됨. get만 만들면됨. 읽기전용.

매출계산등은 쓰기전용함수로만 만드어도됨 즉 get이 없고 set만있어도됨.

멤버변수(비공개,공개가능) 비공개일떄는 멤버함수를 통해 가야함. 
class는 멤버 변수+함수이고 A a B b  이떄 a b를 자료형이라고함.

접근지정자
private 자기 클래스 내부에서만 감능
default 같은패키지내부에서
protected 나를 상속받는 자손들에게 가능,같은패키지내부 
public  모든 패키지 다 접근 가능.


ex Class Point{
	private int x,y;
	
	public int getx(){
	return x;}
	public void getx(int xx){
	x=xx;
}
Point pt=new Point();
sysout(pt.getx()+"m"+pt.getY();

클래스내부에서 선언해주면 값은 0 문자는 null로 셋팅

pt.getx(100);
pt.gety(100);
sys(pt.getx()+pt.getY());100,200;


그런데 포인터에 원을 그리고 싶다면 
class circle extends Point{
	int x,y,r;//근데 x,y가 이미 정의해주는 클래스가 존재하잖?
		//그래서 상속이 생김 만들필요없음 그냥 가져다 쓰면 되는것이니까.

class rectec extends Point{//사각형 찍을려고했는데 x2,y2값만 추가시켜주면 되잖? 포인트 상속시켜주자

}				
소프트웨어 개발속도보다
하드웨어 개발속도를 따라가짐 못하자 소프트웨어 개발  지붕만 만듬 문만 만듦(모듈화)


10일차

하나의 멤버는 두개의 메소드를 가질수가 있다.set,get2개의 메소드

set없으면 읽기전용 get없으면 쓰기 전용

1.한개의 클래스에 1개의 메소드를 가지고 작업하는것은 초반.

2.한개의 클래스에 여러개의 메소드를 만드는것 

10일차에는 다중의 클래스에 다중의 메소드 시작.

만드는 과정 1.코딩레벨 2. 이클립스. 두개의 과정을 모두 설명해줌.

return value;//오직 1개의 값만 리턴한다

return;//제어권을 넘김.


멤버 변수 개수별로 set method만들기를 권장함.한번에 한번의 값만 넣기가 편하니까.